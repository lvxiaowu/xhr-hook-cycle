{"version":3,"sources":["webpack:///ajaxhook.min.js","webpack:///webpack/bootstrap 159f33957ed4f6f391ac","webpack:///./src/xhr-hook.js","webpack:///./src/xhr-proxy.js","webpack:///./src/cdn.js"],"names":["e","a","i","window","modules","__webpack_require__","moduleId","installedModules","exports","module","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","configEvent","event","xhrProxy","attr","target","currentTarget","hook","proxy","getterFactory","v","this","xhr","attrGetterHook","setterFactory","that","substring","attrSetterHook","hookFunction","fun","args","slice","arguments","ret","apply","realXhr","XMLHttpRequest","type","set","getProxy","unHook","undefined","_typeof","Symbol","iterator","obj","constructor","singleton","Proxy","unProxy","trim","str","replace","getEventTarget","watcher","document","createElement","triggerListener","callback","evt","Event","bubbles","createEvent","initEvent","dispatchEvent","Handler","makeHandler","next","sub","create","handleResponse","handler","ResponseHandler","onResponse","resolve","response","status","statusText","config","headers","resHeader","getAllResponseHeaders","split","reduce","ob","shift","join","onerror","ErrorHandler","error","onError","preventXhrProxyCallback","errorCallback","stateChangeCallback","readyState","eventReadyStateChange","onRequest","onload","onloadend","ontimeout","onabort","onreadystatechange","open","_this","method","url","async","user","password","evName","defaultErrorHandler","eventError","eventTimeout","eventAbort","forEach","send","withCredentials","body","req","RequestHandler","setTimeout","setRequestHeader","toLowerCase","addEventListener","events","indexOf","isTrusted","_","header","key","getResponseHeader","eventLoad","eventLoadEnd","responseText","reject","rq","ah"],"mappings":"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","file":"ajaxhook.min.js","sourcesContent":["(function(e, a) { for(var i in a) e[i] = a[i]; }(window, /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 3);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nexports.configEvent = configEvent;\nexports.hook = hook;\nexports.unHook = unHook;\n// Save original XMLHttpRequest as _rxhr\nvar realXhr = \"_rxhr\";\n\nfunction configEvent(event, xhrProxy) {\n  var e = {};\n  for (var attr in event) {\n    e[attr] = event[attr];\n  } // xhrProxy instead\n  e.target = e.currentTarget = xhrProxy;\n  return e;\n}\n\nfunction hook(proxy) {\n  // Avoid double hookAjax\n  window[realXhr] = window[realXhr] || XMLHttpRequest;\n\n  XMLHttpRequest = function XMLHttpRequest() {\n    var xhr = new window[realXhr]();\n    // We shouldn't hookAjax XMLHttpRequest.prototype because we can't\n    // guarantee that all attributes are on the prototype。\n    // Instead, hooking XMLHttpRequest instance can avoid this problem.\n    for (var attr in xhr) {\n      var type = \"\";\n      try {\n        type = _typeof(xhr[attr]); // May cause exception on some browser\n      } catch (e) {}\n      if (type === \"function\") {\n        // hookAjax methods of xhr, such as `open`、`send` ...\n        this[attr] = hookFunction(attr);\n      } else {\n        Object.defineProperty(this, attr, {\n          get: getterFactory(attr),\n          set: setterFactory(attr),\n          enumerable: true\n        });\n      }\n    }\n    var that = this;\n    xhr.getProxy = function () {\n      return that;\n    };\n    this.xhr = xhr;\n  };\n\n  // Generate getter for attributes of xhr\n  function getterFactory(attr) {\n    return function () {\n      var v = this.hasOwnProperty(attr + \"_\") ? this[attr + \"_\"] : this.xhr[attr];\n      var attrGetterHook = (proxy[attr] || {})[\"getter\"];\n      return attrGetterHook && attrGetterHook(v, this) || v;\n    };\n  }\n\n  // Generate setter for attributes of xhr; by this we have an opportunity\n  // to hookAjax event callbacks （eg: `onload`） of xhr;\n  function setterFactory(attr) {\n    return function (v) {\n      var xhr = this.xhr;\n      var that = this;\n      var hook = proxy[attr];\n      // hookAjax  event callbacks such as `onload`、`onreadystatechange`...\n      if (attr.substring(0, 2) === \"on\") {\n        that[attr + \"_\"] = v;\n        xhr[attr] = function (e) {\n          e = configEvent(e, that);\n          var ret = proxy[attr] && proxy[attr].call(that, xhr, e);\n          ret || v.call(that, e);\n        };\n      } else {\n        //If the attribute isn't writable, generate proxy attribute\n        var attrSetterHook = (hook || {})[\"setter\"];\n        v = attrSetterHook && attrSetterHook(v, that) || v;\n        this[attr + \"_\"] = v;\n        try {\n          // Not all attributes of xhr are writable(setter may undefined).\n          xhr[attr] = v;\n        } catch (e) {}\n      }\n    };\n  }\n\n  // Hook methods of xhr.\n  function hookFunction(fun) {\n    return function () {\n      var args = [].slice.call(arguments);\n      if (proxy[fun]) {\n        var ret = proxy[fun].call(this, args, this.xhr);\n        // If the proxy return value exists, return it directly,\n        // otherwise call the function of xhr.\n        if (ret) return ret;\n      }\n      return this.xhr[fun].apply(this.xhr, args);\n    };\n  }\n\n  // Return the real XMLHttpRequest\n  return window[realXhr];\n}\n\nfunction unHook() {\n  if (window[realXhr]) XMLHttpRequest = window[realXhr];\n  window[realXhr] = undefined;\n}\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.proxy = proxy;\nexports.unProxy = unProxy;\n\nvar _xhrHook = __webpack_require__(0);\n\nvar events = [\"load\", \"loadend\", \"timeout\", \"error\", \"readystatechange\", \"abort\"];\nvar eventLoad = events[0],\n    eventLoadEnd = events[1],\n    eventTimeout = events[2],\n    eventError = events[3],\n    eventReadyStateChange = events[4],\n    eventAbort = events[5];\n\nvar singleton,\n    prototype = \"prototype\";\n\nfunction proxy(proxy) {\n  if (singleton) throw \"Proxy already exists\";\n  return singleton = new Proxy(proxy);\n}\n\nfunction unProxy() {\n  singleton = null;\n  (0, _xhrHook.unHook)();\n}\n\nfunction trim(str) {\n  return str.replace(/^\\s+|\\s+$/g, \"\");\n}\n\nfunction getEventTarget(xhr) {\n  return xhr.watcher || (xhr.watcher = document.createElement(\"a\"));\n}\n\nfunction triggerListener(xhr, name) {\n  var xhrProxy = xhr.getProxy();\n  var callback = \"on\" + name + \"_\";\n  var event = (0, _xhrHook.configEvent)({ type: name }, xhrProxy);\n  xhrProxy[callback] && xhrProxy[callback](event);\n  var evt;\n  if (typeof Event === \"function\") {\n    evt = new Event(name, { bubbles: false });\n  } else {\n    // https://stackoverflow.com/questions/27176983/dispatchevent-not-working-in-ie11\n    evt = document.createEvent(\"Event\");\n    evt.initEvent(name, false, true);\n  }\n  getEventTarget(xhr).dispatchEvent(evt);\n}\n\nfunction Handler(xhr) {\n  this.xhr = xhr;\n  this.xhrProxy = xhr.getProxy();\n}\n\nHandler[prototype] = Object.create({\n  resolve: function resolve(response) {\n    var xhrProxy = this.xhrProxy;\n    var xhr = this.xhr;\n    xhrProxy.readyState = 4;\n    xhr.resHeader = response.headers;\n    xhrProxy.response = xhrProxy.responseText = response.response;\n    xhrProxy.statusText = response.statusText;\n    xhrProxy.status = response.status;\n    triggerListener(xhr, eventReadyStateChange);\n    triggerListener(xhr, eventLoad);\n    triggerListener(xhr, eventLoadEnd);\n  },\n  reject: function reject(error) {\n    this.xhrProxy.status = 0;\n    triggerListener(this.xhr, error.type);\n    triggerListener(this.xhr, eventLoadEnd);\n  }\n});\n\nfunction makeHandler(next) {\n  function sub(xhr) {\n    Handler.call(this, xhr);\n  }\n\n  sub[prototype] = Object.create(Handler[prototype]);\n  sub[prototype].next = next;\n  return sub;\n}\n\nvar RequestHandler = makeHandler(function (rq) {\n  var xhr = this.xhr;\n  rq = rq || xhr.config;\n  xhr.withCredentials = rq.withCredentials;\n  xhr.open(rq.method, rq.url, rq.async !== false, rq.user, rq.password);\n  for (var key in rq.headers) {\n    xhr.setRequestHeader(key, rq.headers[key]);\n  }\n  xhr.send(rq.body);\n});\n\nvar ResponseHandler = makeHandler(function (response) {\n  this.resolve(response);\n});\n\nvar ErrorHandler = makeHandler(function (error) {\n  this.reject(error);\n});\n\nfunction Proxy(proxy) {\n  var onRequest = proxy.onRequest,\n      onResponse = proxy.onResponse,\n      onError = proxy.onError;\n\n  function handleResponse(xhr, xhrProxy) {\n    var handler = new ResponseHandler(xhr);\n    if (!onResponse) return handler.resolve();\n    var ret = {\n      response: xhrProxy.response,\n      status: xhrProxy.status,\n      statusText: xhrProxy.statusText,\n      config: xhr.config,\n      headers: xhr.resHeader || xhr.getAllResponseHeaders().split(\"\\r\\n\").reduce(function (ob, str) {\n        if (str === \"\") return ob;\n        var m = str.split(\":\");\n        ob[m.shift()] = trim(m.join(\":\"));\n        return ob;\n      }, {})\n    };\n    onResponse(ret, handler);\n  }\n\n  function onerror(xhr, xhrProxy, e) {\n    var handler = new ErrorHandler(xhr);\n    var error = { config: xhr.config, error: e };\n    if (onError) {\n      onError(error, handler);\n    } else {\n      handler.next(error);\n    }\n  }\n\n  function preventXhrProxyCallback() {\n    return true;\n  }\n\n  function errorCallback(xhr, e) {\n    onerror(xhr, this, e);\n    return true;\n  }\n\n  function stateChangeCallback(xhr, xhrProxy) {\n    if (xhr.readyState === 4 && xhr.status !== 0) {\n      handleResponse(xhr, xhrProxy);\n    } else if (xhr.readyState !== 4) {\n      triggerListener(xhr, eventReadyStateChange);\n    }\n    return true;\n  }\n\n  return (0, _xhrHook.hook)({\n    onload: preventXhrProxyCallback,\n    onloadend: preventXhrProxyCallback,\n    onerror: errorCallback,\n    ontimeout: errorCallback,\n    onabort: errorCallback,\n    onreadystatechange: function onreadystatechange(xhr) {\n      return stateChangeCallback(xhr, this);\n    },\n    open: function open(args, xhr) {\n      var _this = this;\n      var config = xhr.config = { headers: {} };\n      config.method = args[0];\n      config.url = args[1];\n      config.async = args[2];\n      config.user = args[3];\n      config.password = args[4];\n      config.xhr = xhr;\n      var evName = \"on\" + eventReadyStateChange;\n      if (!xhr[evName]) {\n        xhr[evName] = function () {\n          return stateChangeCallback(xhr, _this);\n        };\n      }\n\n      var defaultErrorHandler = function defaultErrorHandler(e) {\n        onerror(xhr, _this, (0, _xhrHook.configEvent)(e, _this));\n      };\n      [eventError, eventTimeout, eventAbort].forEach(function (e) {\n        var event = \"on\" + e;\n        if (!xhr[event]) xhr[event] = defaultErrorHandler;\n      });\n\n      // 如果有请求拦截器，则在调用onRequest后再打开链接。因为onRequest最佳调用时机是在send前，\n      // 所以我们在send拦截函数中再手动调用open，因此返回true阻止xhr.open调用。\n      //\n      // 如果没有请求拦截器，则不用阻断xhr.open调用\n      if (onRequest) return true;\n    },\n    send: function send(args, xhr) {\n      var config = xhr.config;\n      config.withCredentials = xhr.withCredentials;\n      config.body = args[0];\n      if (onRequest) {\n        // In 'onRequest', we may call XHR's event handler, such as `xhr.onload`.\n        // However, XHR's event handler may not be set until xhr.send is called in\n        // the user's code, so we use `setTimeout` to avoid this situation\n        var req = function req() {\n          onRequest(config, new RequestHandler(xhr));\n        };\n        config.async === false ? req() : setTimeout(req);\n        return true;\n      }\n    },\n    setRequestHeader: function setRequestHeader(args, xhr) {\n      // Collect request headers\n      xhr.config.headers[args[0].toLowerCase()] = args[1];\n      return true;\n    },\n    addEventListener: function addEventListener(args, xhr) {\n      var _this = this;\n      if (events.indexOf(args[0]) !== -1) {\n        var handler = args[1];\n        getEventTarget(xhr).addEventListener(args[0], function (e) {\n          var event = (0, _xhrHook.configEvent)(e, _this);\n          event.type = args[0];\n          event.isTrusted = true;\n          handler.call(_this, event);\n        });\n        return true;\n      }\n    },\n    getAllResponseHeaders: function getAllResponseHeaders(_, xhr) {\n      var headers = xhr.resHeader;\n      if (headers) {\n        var header = \"\";\n        for (var key in headers) {\n          header += key + \": \" + headers[key] + \"\\r\\n\";\n        }\n        return header;\n      }\n    },\n    getResponseHeader: function getResponseHeader(args, xhr) {\n      var headers = xhr.resHeader;\n      if (headers) {\n        return headers[(args[0] || \"\").toLowerCase()];\n      }\n    }\n  });\n}\n\n/***/ }),\n/* 2 */,\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ah = undefined;\n\nvar _xhrHook = __webpack_require__(0);\n\nvar _xhrProxy = __webpack_require__(1);\n\n// ah(ajax hook)\nvar ah = exports.ah = {\n  proxy: _xhrProxy.proxy,\n  unProxy: _xhrProxy.unProxy,\n  hook: _xhrHook.hook,\n  unHook: _xhrHook.unHook\n};\n\n/***/ })\n/******/ ])));\n\n\n// WEBPACK FOOTER //\n// ajaxhook.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 159f33957ed4f6f391ac","// Save original XMLHttpRequest as _rxhr\nvar realXhr = \"_rxhr\";\n\nexport function configEvent(event, xhrProxy) {\n  var e = {};\n  for (var attr in event) e[attr] = event[attr];\n  // xhrProxy instead\n  e.target = e.currentTarget = xhrProxy;\n  return e;\n}\n\nexport function hook(proxy) {\n  // Avoid double hookAjax\n  window[realXhr] = window[realXhr] || XMLHttpRequest;\n\n  XMLHttpRequest = function () {\n    var xhr = new window[realXhr]();\n    // We shouldn't hookAjax XMLHttpRequest.prototype because we can't\n    // guarantee that all attributes are on the prototype。\n    // Instead, hooking XMLHttpRequest instance can avoid this problem.\n    for (var attr in xhr) {\n      var type = \"\";\n      try {\n        type = typeof xhr[attr]; // May cause exception on some browser\n      } catch (e) {}\n      if (type === \"function\") {\n        // hookAjax methods of xhr, such as `open`、`send` ...\n        this[attr] = hookFunction(attr);\n      } else {\n        Object.defineProperty(this, attr, {\n          get: getterFactory(attr),\n          set: setterFactory(attr),\n          enumerable: true,\n        });\n      }\n    }\n    var that = this;\n    xhr.getProxy = function () {\n      return that;\n    };\n    this.xhr = xhr;\n  };\n\n  // Generate getter for attributes of xhr\n  function getterFactory(attr) {\n    return function () {\n      var v = this.hasOwnProperty(attr + \"_\")\n        ? this[attr + \"_\"]\n        : this.xhr[attr];\n      var attrGetterHook = (proxy[attr] || {})[\"getter\"];\n      return (attrGetterHook && attrGetterHook(v, this)) || v;\n    };\n  }\n\n  // Generate setter for attributes of xhr; by this we have an opportunity\n  // to hookAjax event callbacks （eg: `onload`） of xhr;\n  function setterFactory(attr) {\n    return function (v) {\n      var xhr = this.xhr;\n      var that = this;\n      var hook = proxy[attr];\n      // hookAjax  event callbacks such as `onload`、`onreadystatechange`...\n      if (attr.substring(0, 2) === \"on\") {\n        that[attr + \"_\"] = v;\n        xhr[attr] = function (e) {\n          e = configEvent(e, that);\n          var ret = proxy[attr] && proxy[attr].call(that, xhr, e);\n          ret || v.call(that, e);\n        };\n      } else {\n        //If the attribute isn't writable, generate proxy attribute\n        var attrSetterHook = (hook || {})[\"setter\"];\n        v = (attrSetterHook && attrSetterHook(v, that)) || v;\n        this[attr + \"_\"] = v;\n        try {\n          // Not all attributes of xhr are writable(setter may undefined).\n          xhr[attr] = v;\n        } catch (e) {}\n      }\n    };\n  }\n\n  // Hook methods of xhr.\n  function hookFunction(fun) {\n    return function () {\n      var args = [].slice.call(arguments);\n      if (proxy[fun]) {\n        var ret = proxy[fun].call(this, args, this.xhr);\n        // If the proxy return value exists, return it directly,\n        // otherwise call the function of xhr.\n        if (ret) return ret;\n      }\n      return this.xhr[fun].apply(this.xhr, args);\n    };\n  }\n\n  // Return the real XMLHttpRequest\n  return window[realXhr];\n}\n\nexport function unHook() {\n  if (window[realXhr]) XMLHttpRequest = window[realXhr];\n  window[realXhr] = undefined;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/xhr-hook.js","import { hook, unHook, configEvent } from \"./xhr-hook\";\n\nvar events = [\n  \"load\",\n  \"loadend\",\n  \"timeout\",\n  \"error\",\n  \"readystatechange\",\n  \"abort\",\n];\nvar eventLoad = events[0],\n  eventLoadEnd = events[1],\n  eventTimeout = events[2],\n  eventError = events[3],\n  eventReadyStateChange = events[4],\n  eventAbort = events[5];\n\nvar singleton,\n  prototype = \"prototype\";\n\nexport function proxy(proxy) {\n  if (singleton) throw \"Proxy already exists\";\n  return (singleton = new Proxy(proxy));\n}\n\nexport function unProxy() {\n  singleton = null;\n  unHook();\n}\n\nfunction trim(str) {\n  return str.replace(/^\\s+|\\s+$/g, \"\");\n}\n\nfunction getEventTarget(xhr) {\n  return xhr.watcher || (xhr.watcher = document.createElement(\"a\"));\n}\n\nfunction triggerListener(xhr, name) {\n  var xhrProxy = xhr.getProxy();\n  var callback = \"on\" + name + \"_\";\n  var event = configEvent({ type: name }, xhrProxy);\n  xhrProxy[callback] && xhrProxy[callback](event);\n  var evt;\n  if (typeof Event === \"function\") {\n    evt = new Event(name, { bubbles: false });\n  } else {\n    // https://stackoverflow.com/questions/27176983/dispatchevent-not-working-in-ie11\n    evt = document.createEvent(\"Event\");\n    evt.initEvent(name, false, true);\n  }\n  getEventTarget(xhr).dispatchEvent(evt);\n}\n\nfunction Handler(xhr) {\n  this.xhr = xhr;\n  this.xhrProxy = xhr.getProxy();\n}\n\nHandler[prototype] = Object.create({\n  resolve: function resolve(response) {\n    var xhrProxy = this.xhrProxy;\n    var xhr = this.xhr;\n    xhrProxy.readyState = 4;\n    xhr.resHeader = response.headers;\n    xhrProxy.response = xhrProxy.responseText = response.response;\n    xhrProxy.statusText = response.statusText;\n    xhrProxy.status = response.status;\n    triggerListener(xhr, eventReadyStateChange);\n    triggerListener(xhr, eventLoad);\n    triggerListener(xhr, eventLoadEnd);\n  },\n  reject: function reject(error) {\n    this.xhrProxy.status = 0;\n    triggerListener(this.xhr, error.type);\n    triggerListener(this.xhr, eventLoadEnd);\n  },\n});\n\nfunction makeHandler(next) {\n  function sub(xhr) {\n    Handler.call(this, xhr);\n  }\n\n  sub[prototype] = Object.create(Handler[prototype]);\n  sub[prototype].next = next;\n  return sub;\n}\n\nvar RequestHandler = makeHandler(function (rq) {\n  var xhr = this.xhr;\n  rq = rq || xhr.config;\n  xhr.withCredentials = rq.withCredentials;\n  xhr.open(rq.method, rq.url, rq.async !== false, rq.user, rq.password);\n  for (var key in rq.headers) {\n    xhr.setRequestHeader(key, rq.headers[key]);\n  }\n  xhr.send(rq.body);\n});\n\nvar ResponseHandler = makeHandler(function (response) {\n  this.resolve(response);\n});\n\nvar ErrorHandler = makeHandler(function (error) {\n  this.reject(error);\n});\n\nfunction Proxy(proxy) {\n  var onRequest = proxy.onRequest,\n    onResponse = proxy.onResponse,\n    onError = proxy.onError;\n\n  function handleResponse(xhr, xhrProxy) {\n    var handler = new ResponseHandler(xhr);\n    if (!onResponse) return handler.resolve();\n    var ret = {\n      response: xhrProxy.response,\n      status: xhrProxy.status,\n      statusText: xhrProxy.statusText,\n      config: xhr.config,\n      headers:\n        xhr.resHeader ||\n        xhr\n          .getAllResponseHeaders()\n          .split(\"\\r\\n\")\n          .reduce(function (ob, str) {\n            if (str === \"\") return ob;\n            var m = str.split(\":\");\n            ob[m.shift()] = trim(m.join(\":\"));\n            return ob;\n          }, {}),\n    };\n    onResponse(ret, handler);\n  }\n\n  function onerror(xhr, xhrProxy, e) {\n    var handler = new ErrorHandler(xhr);\n    var error = { config: xhr.config, error: e };\n    if (onError) {\n      onError(error, handler);\n    } else {\n      handler.next(error);\n    }\n  }\n\n  function preventXhrProxyCallback() {\n    return true;\n  }\n\n  function errorCallback(xhr, e) {\n    onerror(xhr, this, e);\n    return true;\n  }\n\n  function stateChangeCallback(xhr, xhrProxy) {\n    if (xhr.readyState === 4 && xhr.status !== 0) {\n      handleResponse(xhr, xhrProxy);\n    } else if (xhr.readyState !== 4) {\n      triggerListener(xhr, eventReadyStateChange);\n    }\n    return true;\n  }\n\n  return hook({\n    onload: preventXhrProxyCallback,\n    onloadend: preventXhrProxyCallback,\n    onerror: errorCallback,\n    ontimeout: errorCallback,\n    onabort: errorCallback,\n    onreadystatechange: function (xhr) {\n      return stateChangeCallback(xhr, this);\n    },\n    open: function open(args, xhr) {\n      var _this = this;\n      var config = (xhr.config = { headers: {} });\n      config.method = args[0];\n      config.url = args[1];\n      config.async = args[2];\n      config.user = args[3];\n      config.password = args[4];\n      config.xhr = xhr;\n      var evName = \"on\" + eventReadyStateChange;\n      if (!xhr[evName]) {\n        xhr[evName] = function () {\n          return stateChangeCallback(xhr, _this);\n        };\n      }\n\n      var defaultErrorHandler = function defaultErrorHandler(e) {\n        onerror(xhr, _this, configEvent(e, _this));\n      };\n      [eventError, eventTimeout, eventAbort].forEach(function (e) {\n        var event = \"on\" + e;\n        if (!xhr[event]) xhr[event] = defaultErrorHandler;\n      });\n\n      // 如果有请求拦截器，则在调用onRequest后再打开链接。因为onRequest最佳调用时机是在send前，\n      // 所以我们在send拦截函数中再手动调用open，因此返回true阻止xhr.open调用。\n      //\n      // 如果没有请求拦截器，则不用阻断xhr.open调用\n      if (onRequest) return true;\n    },\n    send: function (args, xhr) {\n      var config = xhr.config;\n      config.withCredentials = xhr.withCredentials;\n      config.body = args[0];\n      if (onRequest) {\n        // In 'onRequest', we may call XHR's event handler, such as `xhr.onload`.\n        // However, XHR's event handler may not be set until xhr.send is called in\n        // the user's code, so we use `setTimeout` to avoid this situation\n        var req = function () {\n          onRequest(config, new RequestHandler(xhr));\n        };\n        config.async === false ? req() : setTimeout(req);\n        return true;\n      }\n    },\n    setRequestHeader: function (args, xhr) {\n      // Collect request headers\n      xhr.config.headers[args[0].toLowerCase()] = args[1];\n      return true;\n    },\n    addEventListener: function (args, xhr) {\n      var _this = this;\n      if (events.indexOf(args[0]) !== -1) {\n        var handler = args[1];\n        getEventTarget(xhr).addEventListener(args[0], function (e) {\n          var event = configEvent(e, _this);\n          event.type = args[0];\n          event.isTrusted = true;\n          handler.call(_this, event);\n        });\n        return true;\n      }\n    },\n    getAllResponseHeaders: function (_, xhr) {\n      var headers = xhr.resHeader;\n      if (headers) {\n        var header = \"\";\n        for (var key in headers) {\n          header += key + \": \" + headers[key] + \"\\r\\n\";\n        }\n        return header;\n      }\n    },\n    getResponseHeader: function (args, xhr) {\n      var headers = xhr.resHeader;\n      if (headers) {\n        return headers[(args[0] || \"\").toLowerCase()];\n      }\n    },\n  });\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/xhr-proxy.js","import { hook, unHook } from \"./xhr-hook\";\nimport { proxy, unProxy } from \"./xhr-proxy\";\n// ah(ajax hook)\nexport var ah = {\n  proxy,\n  unProxy,\n  hook,\n  unHook,\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/cdn.js"],"sourceRoot":""}